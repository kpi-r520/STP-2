# Современные технологии программирования - 2
## Лабораторная работа №3. ШАБЛОНЫ «ОДИНОЧКА», «ИТЕРАТОР», «ПРОКСИ», «СОСТОЯНИЕ», «СТРАТЕГИЯ».

### Задание

1. Ознакомиться с краткими теоретическими сведениями.
2. Реализовать часть функционала рабочей программы в виде классов и их взаимодействий для достижения конкретных функциональных возможностей.
3. Применение одного из рассматриваемых шаблонов при реализации программы.
 
### Краткие теоретические сведения

** Что такое шаблоны проектирования ? **

Любой паттерн проектирования, используемый при разработке информационных систем, представляет собой формализованное описание часто встречающейся задачи проектирования, удачное решение данной задачи, а также рекомендации по применению этого решения в различных ситуациях. Кроме того, паттерн проектирования обязательно имеет общеупотребимое наименование. Правильно сформулированный паттерн проектирования позволяет, отыскав однажды удачное решение, пользоваться им снова и снова. Следует подчеркнуть, что важным начальным этапом при работе с паттернами является адекватное моделирование рассматриваемой предметной области. Это является необходимым как для получения должным образом формализованной постановки задачи, так и для выбора подходящих паттернов проектирования. 

Сообразное использование паттернов проектирования дает разработчику ряд неоспоримых преимуществ. Приведем некоторые из них. Модель системы, построенная в терминах паттернов проектирования, фактически является структурированным выделением тех элементов и связей, которые значимы при решении поставленной задачи. Помимо этого, модель, построенная с использованием паттернов проектирования, более проста и наглядна в изучении, чем стандартная модель. Тем не менее, несмотря на простоту и наглядность, она позволяет глубоко и всесторонне проработать архитектуру разрабатываемой системы с использованием специального языка. Применение паттернов проектирования повышает устойчивость системы к изменению требований и упрощает неизбежную последующую доработку системы. Кроме того, трудно переоценить роль использования паттернов при интеграции информационных систем организации. Также следует упомянуть, что совокупность паттернов проектирования, по сути, представляет собой единый словарь проектирования, который, будучи унифицированным средством, незаменим для общения разработчиков друг другом.

Таким образом шаблоны представляют собой подтвержденные годами разработок в различных компаниях и на различных проектах «эскизы» архитектурных решений, которые удобно применять в соответствующих обстоятельствах.

** Зачем использовать шаблоны ? **

Применение шаблонов проектирования не гарантирует, что разработанная архитектура будет кристально чистой и удобной с точки зрения программирования. Однако в подходящих местах применение шаблонов позволит достичь следующих выгод:

* Уменьшение трудозатрат и времени на построение архитектуры;
* Придание проектируемой системе необходимых качеств (гибкость, адаптируемость, проч.);
* Уменьшить накладные расходы на дальнейшую поддержку системы;
* И другие.

Следует также отметить, что знание шаблонов проектирования помогает не только архитекторам программных систем, но и разработчикам. Когда каждый человек в команде знает значение и свойства шаблонов, архитектору проще донести общую идею архитектуры системы, а разработчикам – проще понять.

Поскольку в конце концов каждый бизнес сводится к деньгам, шаблоны проектирования также представляют собой экономически оправданный выбор между построением собственного «колеса» и реализацией закрепленных и гарантированных сообществом разработчиков практик и подходов. Это конечно же не значит, что их необходимо использовать в каждом проекте на каждом требовании. Подходы не являются догмой, их нужно использовать с головой.

**Шаблон «Одиночка»**

![Одиночка](https://github.com/kpi-r520/STP/blob/master/images/singleton_diagram.png)

«Одиночка» представляет собой класс в терминах ООП, который может иметь не более одного объекта (отсюда и название «одиночка»). На самом деле, количество объектов
можно задать (т.е. нельзя создать более n объектов данного класса). Данный объект чаще всего хранится как статическое поле в самом классе. Использование одиночки оправдано для следующих случаев:

* Может быть не более N физических объектов, отображаемых в определенные классы;
* Необходимо жестко контролировать все операции, проходящие через данный класс.

Первый случай легко продемонстрировать. У каждого приложения есть некоторый набор настроек, который как правило сохраняется в отдельный файл (для современных компьютерных игр это может быть .ini файл, для .net приложений - .xml файл). Этот файл – единственный, и потому использование множества объектов для загрузки/записи данных – нерациональное решение.

Для демонстрации второго случая, рассмотрим следующий пример. Допустим, существует две взаимодействующие системы, между которыми установлен сеанс связи. Наложены ограничения, что по данному сеансу связи данные могут идти в один момент времени лишь в одну сторону. Таким образом, на каждый посланный запрос необходимо дождаться ответа, прежде чем отсылать новый запрос. Объект-«одиночка» позволит не только содержать ровно один сеанс связи, но и еще реализовать соответствующую логику проверок на основе bool операторов о возможности посылки запроса и, возможно, некоторую очередь запросов.

Следует однако отметить, что в настоящее время «одиночку» многие считают т.н. «анти-шаблоном», т.е. плохой практикой проектирования. Это связано с тем, что «одиночки» представляют собой глобальные данные (как глобальная переменная), имеющие состояние. Состояние глобальных объектов тяжело отслеживать и поддерживать корректным; также глобальные объекты тяжело тестируются и вносят сложность в программный код (во всех участках кода вызов в одно единственное место с «одиночкой»; при смене подхода придется изменять массу кода). При этом реализация контроля доступа возможна при помощи статических переменных, замыканий, мютексов и других специальных структур.

**Шаблон «Итератор»**

![Итератор](https://github.com/kpi-r520/STP/blob/master/images/iterator_diagram.png)

«Итератор» представляет собой шаблон реализации объекта доступа к набору (коллекции, агрегату) элементов без раскрытия внутренних механизмов реализации. Итератор выносит функциональность перебора коллекции элементов из самой коллекции, таким образом достигается разделение обязанностей: коллекция отвечает за хранение данных, итератор – за проход по коллекции. 

При этом алгоритм итератора может изменяться – при необходимости пройти в обратном порядке используется другой итератор. Возможно также написание такого итератора, который проходит список сначала по четным позициям (2,4,6й элементы и т.д.), потом по нечетным. То есть, шаблон итератор позволяет реализовывать различные способы прохождения по коллекции независимо от вида и способа представления данных в коллекции.

Также, этот шаблон позволяет унифицировать операции прохождения по наборам объектов для всех наборов. Т.е. вне зависимости от реализации (массив, связанный список, несвязанный список, дерево и др.), каждый из наборов может использовать любой из реализованных итераторов.

Шаблонный итератор содержит:
* First() – установка указателя перебора на первый элемент коллекции;
* Next() – установка указателя перебора на следующий элемент коллекции;
* IsDone – булевское поле, устанавливающееся в true когда указатель перебора достиг конца коллекции;
* CurrentItem – текущий объект коллекции.

**Шаблон «Прокси»**

![Прокси](https://github.com/kpi-r520/STP/blob/master/images/proxy_diagram.png)

«Прокси»-объекты являются объектами-заглушками или двойниками/заменителями для объектов конкретного типа. Обычно, прокси объекты вносят дополнительный
функционал или упрощают взаимодействие с настоящими объектами. Прокси объекты использовались в более ранних версиях интернет-браузеров, например, для отображения картинки: пока картинка загружается, пользователю отображается «заглушка» картинки, выглядевшая так:

![Заглушка IE](https://github.com/kpi-r520/STP/blob/master/images/ie_stub.png)

В качестве другого примера объектов заглушек можно привести аспектно-ориентированное программирование. Например, необходимо добавить лог сообщение при каждом доступе к отдельному полю объектов определенного класса. Есть также ограничение, что изменять программный код класса нельзя. В таком случае, вместо каждого такого объекта создается прокси объект, который при вызове этого метода переадресует вызов реальному объекту, но перед этим записывает лог сообщение.

Прокси объект полностью повторяет определение объекта, который он заменяет (т.е. все доступные методы, поля и свойства); прокси объект может также хранить ссылку на реальный объект, в случае если он расширяет функциональность, т.е. «оборачивает» реальный объект.

**Шаблон «Состояние»**

![Состояние](https://github.com/kpi-r520/STP/blob/master/images/state_diagram.png)

Шаблон «состояние» позволяет изменять логику работы объектов в случае изменения их внутреннего состояния. Например, процент начисляемых на карточный счет денег зависит от состояния карточки: Visa Electron, Classic, Platinum и т.д. Или объем услуг, предоставляемых хостинг компанией, изменяется в зависимости от выбранного тарифного плана (состояния членства – бронзовый, серебрянный или золотой клиент).

Реализация данного шаблона состоит в следующем: относящиеся к состоянию поля, свойства, методы и действия выносятся в отдельный общий интерфейс (State); каждое состояние представляет собой отдельный класс (ConcreteStateA, ConcreteStateB) реализующие общий интерфейс. Объекты, имеющие состояние (Context), при смене состояния просто записывают новый объект в поле state, что приводит к полному изменению поведения объекта.

Это позволяет легко добавлять в будущем и обрабатывать новые состояния, отделять зависящие от состояния элементы объекта в других объектах, и открыто производить замену состояния (что имеет смысл во многих случаях).

**Шаблон «Стратегия»**

Шаблон «стратегия» позволяет изменять некоторый алгоритм поведения объекта другим алгоритмом, достигающим ту же цель иным способом. Примером могут служить алгоритмы сортировки: каждый алгоритм имеет собственную реализацию и определен в отдельном классе; они могут быть взимозаменяемы в объекте, их использующем.

![Стратегия](https://github.com/kpi-r520/STP/blob/master/images/strategy_diagram.png)

Данный шаблон очень удобен в случаях, когда существуют разные «политики» обработки данных. По сути он очень похож на шаблон «состояние», однако используется в совершенно других целях – независимо от состояния объекта отобразить различные возможные поведения объекта (которыми достигаются одни и те же или схожие цели).

Например, программное обеспечение по перекодированию видео из одного формата в другой может реализовывать алгоритмы кодирования/декодирования при помощи шаблона стратегия следующим образом:
```
public interface IEncoder
{
	byte[] Encode(byte[] rawData);
}
public class H264Encoder: IEncoder
{…}
public class OGGEncoder : IEncoder
{…}
public class Transcoder
{
	private IEncoder _enc;
	public void Transcode(string file, string format)
	{
		switch (format)
		{
			case “h264”: _encDec = new H264Encoder ();break;
			case “ogg”: _encDec = new OGGEncoder ();break;
			default: break;
		}
		If (_enc != null)
			File.Write(“newfile.avi”,_enc.Encode(file.ReadAllBytes());
	}
}
```

**Контрольные вопросы**

1. Что такое шаблон проектирования ?
2. Зачем использовать шаблоны проектирования ?
3. Чем отличается шаблон «стратегия» от «состояния» ?
4. В чем заключается идея шаблона «одиночка» ? Почему его считают «анти-шаблоном» ?
5. Зачем использовать шаблон «прокси» ?